<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Layered GIF Canvas Player (ES Modules)</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    background: black;
  }
  body {
    display: flex; justify-content: center; align-items: center;
  }
  #canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: black;
  }
  #loading {
    position: fixed;
    top: 10px; left: 10px;
    color: white;
    font-family: monospace;
    font-size: 14px;
  }
</style>
</head>
<body>

<div id="loading">Loading...</div>
<canvas id="canvas"></canvas>

<script type="module">
    /* esm.sh bundles gifuct-js and all its deps into a single file.
       “?bundle” guarantees there are NO further imports.              */
    import { parseGIF, decompressFrames } from
      'https://esm.sh/gifuct-js@2.1.2?bundle';


// Utility: fetch text file lines trimmed
async function fetchList(path) {
  const res = await fetch(path);
  if (!res.ok) throw new Error(`Failed to load ${path}`);
  const text = await res.text();
  return text.split('\n').map(s => s.trim()).filter(Boolean);
}

// Utility: load static image as ImageBitmap
async function loadImageBitmap(url) {
  const img = await new Promise((resolve, reject) => {
    const image = new Image();
    image.crossOrigin = "anonymous";
    image.onload = () => resolve(image);
    image.onerror = reject;
    image.src = url;
  });
  return await createImageBitmap(img);
}

/* ────────────────────────────────────────────────────────────
   Helper: return something Safari accepts for createPattern
   (Canvas, <img>, <video> or null) and cache bitmap→canvas
   ──────────────────────────────────────────────────────────── */
   function patternSource(frame) {
  if (!frame) return null;                            // nothing

  // Safari refuses ImageBitmap
  if (frame instanceof ImageBitmap) {
    let c = patternSource.cache.get(frame);
    if (!c) {
      c = document.createElement('canvas');
      c.width = frame.width;
      c.height = frame.height;
      c.getContext('2d').drawImage(frame, 0, 0);
      patternSource.cache.set(frame, c);
    }
    return c;
  }

  // guard against zero-sized canvases
  if (!frame.width || !frame.height) return null;

  return frame;                                      // already OK
}
patternSource.cache = new WeakMap();


// Decode GIF into frames (ImageBitmaps) and frame durations
async function decodeGif(arrayBuffer) {
  const gif = parseGIF(arrayBuffer);
  const frames = decompressFrames(gif, true);
  const bitmaps = [];
  for (const frame of frames) {
    const canvas = document.createElement('canvas');
    canvas.width = frame.dims.width;
    canvas.height = frame.dims.height;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(frame.dims.width, frame.dims.height);
    imageData.data.set(frame.patch);
    ctx.putImageData(imageData, 0, 0);
    // const bitmap = await createImageBitmap(canvas);
    // bitmaps.push(bitmap);
    bitmaps.push(canvas);              // canvas works in all browsers
  }
  const delays = frames.map(f => (f.delay || 10) * 10); // delay is 10ms units, default 100ms
  return { frames: bitmaps, delays, width: gif.lsd.width, height: gif.lsd.height };
}

// Load either static image or GIF decoded frames
async function loadMedia(url) {
  if (url.toLowerCase().endsWith('.gif')) {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Failed to load ${url}`);
    const buffer = await resp.arrayBuffer();
    const gifData = await decodeGif(buffer);
    return gifData;
  } else {
    const bitmap = await loadImageBitmap(url);
    return {
      frames: [bitmap],
      delays: [1000], // 1s static frame
      width: bitmap.width,
      height: bitmap.height
    };
  }
}

// Layer class holds current and next image data + animation/crossfade info
class Layer {
  constructor(name, isTiled = false) {
    this.name = name;
    this.isTiled = isTiled;

    this.current = null;    // { frames, delays, width, height }
    this.next = null;

    this.currentStart = 0;  // timestamp when current animation started
    this.nextStart = null;  // timestamp when crossfade started

    this.crossfadeDuration = 2000; // ms
    this.crossfading = false;
  }

  setCurrent(imageData, timestamp) {
    this.current = imageData;
    this.currentStart = timestamp;
    this.crossfading = false;
    this.next = null;
    this.nextStart = null;
  }

  setNext(imageData, timestamp) {
    this.next = imageData;
    this.nextStart = timestamp;
    this.crossfading = true;
  }

  getFrameIndex(imageData, startTime, now) {
    if (!imageData) return 0;
    const elapsed = now - startTime;
    const totalDuration = imageData.delays.reduce((a,b) => a + b, 0);
    let t = elapsed % totalDuration;
    for(let i=0; i<imageData.frames.length; i++) {
      if (t < imageData.delays[i]) return i;
      t -= imageData.delays[i];
    }
    return 0;
  }
}

// Main player managing layers and animation
class LayeredGifPlayer {
  constructor(canvas, loadingEl) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.loadingEl = loadingEl;

    this.bgList = [];
    this.overlayList = [];

    this.bgLayer = new Layer("background", true);
    this.ov1Layer = new Layer("overlay1");
    this.ov2Layer = new Layer("overlay2");

    this.width = window.innerWidth;
    this.height = window.innerHeight;

    this.canvas.width = this.width;
    this.canvas.height = this.height;

    this.lastTimestamp = 0;
    this.bgChangeInterval = 12000;
    this.ovChangeInterval = 7000;

    this.nextBgChange = 0;
    this.nextOvChange = 0;

    window.addEventListener('resize', () => this.onResize());
  }

  async init() {
    this.loadingEl.textContent = "Loading image lists...";
    this.bgList = await fetchList('./bg/_list.txt');
    this.overlayList = await fetchList('./img/_list.txt');

    this.loadingEl.textContent = "Loading initial images...";
    await this.loadInitialImages();

    this.loadingEl.style.display = 'none';

    requestAnimationFrame(timestamp => this.loop(timestamp));
  }

  async loadInitialImages() {
    const now = performance.now();

    this.bgLayer.setCurrent(await this.loadRandomImage(this.bgList, true), now);
    this.bgLayer.setNext(await this.loadRandomImage(this.bgList, true), now);

    this.ov1Layer.setCurrent(await this.loadRandomImage(this.overlayList), now);
    this.ov1Layer.setNext(await this.loadRandomImage(this.overlayList), now);

    this.ov2Layer.setCurrent(await this.loadRandomImage(this.overlayList), now);
    this.ov2Layer.setNext(await this.loadRandomImage(this.overlayList), now);
  }

  async loadRandomImage(list, isTiled = false) {
    const file = list[Math.floor(Math.random() * list.length)];
    const url = (isTiled ? './bg/' : './img/') + file;
    try {
      const media = await loadMedia(url);
      return media;
    } catch(e) {
      console.error("Error loading image", url, e);
      return null;
    }
  }

  onResize() {
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
  }

  async swapNextImages(timestamp) {
    // Background
    if (timestamp > this.nextBgChange) {
      if (!this.bgLayer.crossfading) {
        this.bgLayer.setNext(await this.loadRandomImage(this.bgList, true), timestamp);
        this.bgLayer.crossfading = true;
        this.bgLayer.nextStart = timestamp;
        this.nextBgChange = timestamp + this.bgChangeInterval;
      } else if (timestamp - this.bgLayer.nextStart >= this.bgLayer.crossfadeDuration) {
        this.bgLayer.setCurrent(this.bgLayer.next, timestamp);
        this.bgLayer.next = null;
        this.bgLayer.crossfading = false;
      }
    }

    // Overlay layers
    if (timestamp > this.nextOvChange) {
      if (!this.ov1Layer.crossfading) {
        this.ov1Layer.setNext(await this.loadRandomImage(this.overlayList), timestamp);
        this.ov2Layer.setNext(await this.loadRandomImage(this.overlayList), timestamp);
        this.ov1Layer.crossfading = this.ov2Layer.crossfading = true;
        this.ov1Layer.nextStart = this.ov2Layer.nextStart = timestamp;
        this.nextOvChange = timestamp + this.ovChangeInterval;
      } else if (timestamp - this.ov1Layer.nextStart >= this.ov1Layer.crossfadeDuration) {
        this.ov1Layer.setCurrent(this.ov1Layer.next, timestamp);
        this.ov1Layer.next = null;
        this.ov1Layer.crossfading = false;

        this.ov2Layer.setCurrent(this.ov2Layer.next, timestamp);
        this.ov2Layer.next = null;
        this.ov2Layer.crossfading = false;
      }
    }
  }

  drawLayer(layer, timestamp) {
    if (!layer.current) return;
    const ctx = this.ctx;

    const fadeProgress = layer.crossfading && layer.nextStart
      ? Math.min((timestamp - layer.nextStart)/layer.crossfadeDuration, 1)
      : 0;

    // Current image frame
    const currentFrameIdx = layer.getFrameIndex(layer.current, layer.currentStart, timestamp);
    const currentFrame = layer.current.frames[currentFrameIdx];

    // Next image frame (if crossfading)
    let nextFrame = null;
    if (layer.crossfading && layer.next) {
      const nextFrameIdx = layer.getFrameIndex(layer.next, layer.nextStart, timestamp);
      nextFrame = layer.next.frames[nextFrameIdx];
    }

    ctx.save();

    if (layer.isTiled) {
      const src1 = patternSource(currentFrame);
      const src2 = patternSource(nextFrame);

      if (src1) {
        ctx.globalAlpha = 1 - fadeProgress;
        ctx.fillStyle   = ctx.createPattern(src1, 'repeat');
        ctx.fillRect(0, 0, this.width, this.height);
      }
      if (fadeProgress > 0 && src2) {
        ctx.globalAlpha = fadeProgress;
        ctx.fillStyle   = ctx.createPattern(src2, 'repeat');
        ctx.fillRect(0, 0, this.width, this.height);
      }
    } else {
      // Center overlays with scaling
      const drawFrame = (frame, alpha) => {
        if (!frame) return;
        ctx.globalAlpha = alpha;
        const scale = Math.min(this.width / frame.width, this.height / frame.height);
        const dw = frame.width * scale;
        const dh = frame.height * scale;
        const dx = (this.width - dw) / 2;
        const dy = (this.height - dh) / 2;
        ctx.drawImage(frame, dx, dy, dw, dh);
      };
      drawFrame(currentFrame, 1 - fadeProgress);
      if (nextFrame) drawFrame(nextFrame, fadeProgress);
    }

    ctx.restore();
  }

  async loop(timestamp) {
    if (!this.lastTimestamp) this.lastTimestamp = timestamp;
    const elapsed = timestamp - this.lastTimestamp;
    this.lastTimestamp = timestamp;

    await this.swapNextImages(timestamp);

    this.ctx.clearRect(0, 0, this.width, this.height);

    this.drawLayer(this.bgLayer, timestamp);
    this.drawLayer(this.ov1Layer, timestamp);
    this.drawLayer(this.ov2Layer, timestamp);

    requestAnimationFrame(t => this.loop(t));
  }
}

// Main startup
const canvas = document.getElementById('canvas');
const loadingEl = document.getElementById('loading');

async function main() {
  const player = new LayeredGifPlayer(canvas, loadingEl);
  try {
    await player.init();
  } catch (e) {
    loadingEl.textContent = `Error initializing: ${e.message}`;
    console.error(e);
  }
}
main();
</script>

</body>
</html>